# This is a basic workflow to help you get started with Actions

name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  repository_dispatch:
    types: [RancherK8s]

jobs:
  deploy:
    runs-on: ubuntu-latest  # Runs on GitHub-hosted runner

    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v3

      - name: ðŸ› ï¸ Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: ðŸ” Debug - List Files and Current Directory
        run: |
          echo "ðŸ” Current Directory:"
          pwd  # Print working directory

          echo "ðŸ“‚ Listing all files in the repository:"
          ls -R  # List all files recursively

     # - name: ðŸ”‘ Configure Kubeconfig
     #   run: |
     #     mkdir -p $HOME/.kube  # Ensure .kube directory exists
     #     echo "${{ secrets.KUBECONFIG_BASE64 }}" > $HOME/.kube/ca.crt
     #     chmod 600 $HOME/.kube/ca.crt
          
    #      export KUBECONFIG=$GITHUB_WORKSPACE/config  # Explicitly set kubeconfig

          # âœ… Debug: Print Kubeconfig Contents
    #      echo "ðŸ” Debug: Kubeconfig File Contents:"
    #      cat $GITHUB_WORKSPACE/config

      - name: âš ï¸ Disable TLS Verification for Local Cluster
        run: |
          export KUBECONFIG=$GITHUB_WORKSPACE/local.yaml
          echo "âš ï¸ Enabling --insecure-skip-tls-verify for 'local' cluster..."
          kubectl config set-cluster local --insecure-skip-tls-verify=true


          # âœ… Debug: Check Namespaces
          echo "ðŸ” Debug: Checking Namespaces..."
          kubectl get ns || echo "âŒ Failed to fetch namespaces"

      - name: ðŸ” Log event payload to a file
        run: echo '${{ toJson(github.event.client_payload) }}' > event_payload.json

      - name: ðŸ” Print JSON payload for debugging
        run: |
          echo "ðŸ“‚ Listing all files:"
          ls -l
          echo "ðŸ“„ JSON Payload Content:"
          cat event_payload.json

      - name: Extract metadata for Docker image name
        run: |
          # Extract values from JSON
          ORG_ID=$(jq -r '.data.organizationID' event_payload.json)
          SUB_ORG_ID=$(jq -r '.data.subOrganizationID' event_payload.json)
          ENV_ID=$(jq -r '.data.enviromentID' event_payload.json)
          GRAPH_ID=$(jq -r '.data.graphID' event_payload.json)
          VERSION=$(jq -r '.data.version' event_payload.json)

          # Validate extracted values
          if [[ -z "$ORG_ID" || -z "$SUB_ORG_ID" || -z "$ENV_ID" || -z "$GRAPH_ID" || -z "$VERSION" ]]; then
            echo "ðŸš¨ Error: One or more required fields are missing!"
            exit 1
          fi

          # Generate Docker Image Name
          IMAGE_NAME="ravi8881/${ORG_ID}-${SUB_ORG_ID}-${ENV_ID}-${GRAPH_ID}:${VERSION}"
          IMAGE_NAME=$(echo $IMAGE_NAME | tr '[:upper:]' '[:lower:]' | tr -d ' ' | tr '/' '-')

      - name: ðŸ”„ Clone solr-docker repository with dynamic branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Extract branch name from payload
          BRANCH_NAME=$(jq -r '.data.organizationID' event_payload.json)

          # Validate
          if [[ -z "$BRANCH_NAME" ]]; then
            echo "ðŸš¨ Error: branchName is missing in payload!"
            exit 1
          fi

          echo "ðŸ” Cloning branch: $BRANCH_NAME"

          # Clone the solr-docker repo with the provided branch
          git clone --single-branch --branch "$BRANCH_NAME" \
            https://x-access-token:${GITHUB_TOKEN}@github.com/ravi-dhyani8881/solr-docker.git solr-docker

          # List contents
          ls -la solr-docker

      - name: ðŸ“‚ Navigate into dynamic subdirectory
        run: |
          SUB_ORG_ID=$(jq -r '.data.subOrganizationID' event_payload.json)
          ENV_ID=$(jq -r '.data.enviromentID' event_payload.json)
          GRAPH_ID=$(jq -r '.data.graphID' event_payload.json)

          # Validate
          if [[ -z "$SUB_ORG_ID" || -z "$ENV_ID" || -z "$GRAPH_ID" ]]; then
            echo "ðŸš¨ Error: One or more folder names are missing!"
            exit 1
          fi

          TARGET_PATH="solr-docker/$SUB_ORG_ID/$ENV_ID/$GRAPH_ID"

          echo "ðŸ“ Changing into: $TARGET_PATH"

          if [[ -d "$TARGET_PATH" ]]; then
            cd "$TARGET_PATH"
            ls -la
          else
            echo "âŒ Directory $TARGET_PATH does not exist!"
            exit 1
          fi
      
      - name: ðŸš€ Apply Kubernetes Manifests
        run: |
          SUB_ORG_ID=$(jq -r '.data.subOrganizationID' event_payload.json)
          ENV_ID=$(jq -r '.data.enviromentID' event_payload.json)
          GRAPH_ID=$(jq -r '.data.graphID' event_payload.json)

          MANIFEST_DIR="solr-docker/$SUB_ORG_ID/$ENV_ID/$GRAPH_ID/kubernates"

          echo "ðŸ“‚ Applying manifests from: $MANIFEST_DIR"

          if [[ -d "$MANIFEST_DIR" ]]; then
            kubectl apply -f "$MANIFEST_DIR/solr-deployment.yaml"
            kubectl apply -f "$MANIFEST_DIR/solr-service.yaml"
            kubectl apply -f "$MANIFEST_DIR/solr-ingress.yaml"
          else
            echo "âŒ Manifest directory does not exist!"
            exit 1
          fi


          # Log and Export Variables
          echo "ðŸš€ Docker Image Name: $IMAGE_NAME"
          echo "DOCKER_IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_ENV
